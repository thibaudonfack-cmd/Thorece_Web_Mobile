@startuml Sequence_Register_CipeStudio

actor Utilisateur
participant "RegisterPage\n(Frontend)" as Frontend
participant "UserController\n(Backend)" as Controller
participant "UserService" as Service
participant "UserRepository" as Repo
participant "EmailService" as EmailSvc
database "MySQL" as DB
cloud "SMTP Server" as SMTP

== Inscription d'un nouvel utilisateur ==

Utilisateur -> Frontend: Accéder à /register
activate Frontend
Frontend --> Utilisateur: Afficher formulaire\n(nom, email, password, rôle)
deactivate Frontend

Utilisateur -> Frontend: Remplir et soumettre\nle formulaire
activate Frontend

Frontend -> Frontend: Validation côté client\n(format email, longueur password)

note right of Frontend
  **Validations frontend** :
  • Email : regex email valide
  • Mot de passe : min 8 caractères
  • Nom : non vide
  • Rôle : ENFANT, AUTEUR ou EDITEUR
end note

Frontend -> Controller: POST /auth/register\n{name, email, password, role}
activate Controller

note right of Controller
  **Request DTO** :
  {
    "name": "John Doe",
    "email": "john@example.com",
    "password": "securePass123",
    "role": "AUTEUR"
  }
end note

Controller -> Controller: Valider avec @Valid\n(Jakarta Validation)

note right of Controller
  **Annotations de validation** :
  • @NotBlank(name)
  • @Email(email)
  • @Size(min=8, password)
  • @NotNull(role)
end note

alt Validation échoue
  Controller --> Frontend: 400 Bad Request\n{errors: [...]}
  Frontend --> Utilisateur: Afficher erreurs\nde validation
else Validation réussit

  Controller -> Service: register(registerRequestDTO)
  activate Service

  Service -> Repo: findByEmail(email)
  activate Repo
  Repo -> DB: SELECT * FROM users\nWHERE email = ?
  activate DB
  DB --> Repo: Résultat (null ou User)
  deactivate DB
  Repo --> Service: Optional<User>
  deactivate Repo

  alt Email existe déjà
    Service --> Controller: throw UserAlreadyExistsException
    Controller --> Frontend: 409 Conflict\n{"message": "Email already exists"}
    Frontend --> Utilisateur: "Cet email est\ndéjà utilisé"
  else Email disponible

    Service -> Service: Hasher le mot de passe\navec BCryptPasswordEncoder

    note right of Service
      **BCrypt Hashing** :
      • Algorithme : bcrypt
      • Rounds : 10 (2^10 = 1024 itérations)
      • Salt : généré automatiquement

      Exemple :
      "password123" →
      "$2a$10$N9qo8uL..."
      (60 caractères)
    end note

    Service -> Service: Créer entité User
    Service -> Service: Générer code OTP\n(6 chiffres aléatoires)

    note right of Service
      **Génération OTP** :
      ```java
      Random random = new Random();
      int otp = random.nextInt(900000) + 100000;
      // Résultat : 100000-999999 (6 chiffres)
      ```

      Expiration : maintenant + 5 minutes
    end note

    Service -> Service: Définir otp_expiry_date\n(maintenant + 5 minutes)
    Service -> Service: is_verified = false\nis_blocked = false

    Service -> Repo: save(user)
    activate Repo
    Repo -> DB: INSERT INTO users\n(name, email, password,\nrole, otp_code, otp_expiry_date,\nis_verified, is_blocked,\ncreated_at, updated_at)
    activate DB

    note right of DB
      **Contraintes DB** :
      • UNIQUE(email)
      • NOT NULL(name, email, password, role)
      • DEFAULT(is_verified=false, is_blocked=false)
    end note

    DB --> Repo: User créé (avec ID)
    deactivate DB
    Repo --> Service: User
    deactivate Repo

    == Envoi de l'email OTP ==

    Service -> EmailSvc: sendOtpEmail(user.email, otpCode)
    activate EmailSvc

    EmailSvc -> EmailSvc: Composer le message\nHTML/texte

    note right of EmailSvc
      **Contenu email** :

      Subject: "Code de vérification - Cipe Studio"

      Body (HTML) :
      "Bonjour {name},

      Votre code de vérification est : **{otpCode}**

      Ce code expire dans 5 minutes.

      Si vous n'avez pas demandé ce code,
      ignorez cet email.

      L'équipe Cipe Studio"
    end note

    EmailSvc -> SMTP: Envoyer email via JavaMailSender
    activate SMTP

    alt Envoi email réussi
      SMTP --> EmailSvc: 250 OK (Message accepté)
      deactivate SMTP
      EmailSvc --> Service: Email envoyé
      deactivate EmailSvc

      Service --> Controller: RegisterResponseDTO
      deactivate Service

      note right of Service
        **Response DTO** :
        {
          "id": 123,
          "name": "John Doe",
          "email": "john@example.com",
          "role": "AUTEUR",
          "isVerified": false
        }

        ⚠️ Le mot de passe et l'OTP ne sont
        JAMAIS inclus dans la réponse !
      end note

      Controller --> Frontend: 201 Created\n{user data}
      deactivate Controller

      Frontend -> Frontend: Sauvegarder email\nen sessionStorage

      Frontend --> Utilisateur: "Inscription réussie !\nVérifiez votre email"

      Frontend -> Frontend: Rediriger vers\n/verify-otp?email={email}

      note right of Frontend
        La page de vérification OTP
        est maintenant affichée avec
        un champ pour saisir le code
        reçu par email.
      end note

    else Envoi email échoué
      SMTP --> EmailSvc: Erreur SMTP\n(timeout, auth failed, etc.)
      deactivate SMTP
      EmailSvc --> Service: throw EmailSendException
      deactivate EmailSvc

      note right of EmailSvc
        **Gestion erreur email** :

        Option 1 (actuel) :
        • Exception → 500 Internal Server Error
        • Utilisateur ne peut pas se connecter

        Option 2 (recommandé) :
        • Logger l'erreur
        • Retourner 201 Created quand même
        • Ajouter endpoint "Renvoyer OTP"
      end note

      Service --> Controller: throw EmailSendException
      deactivate Service
      Controller --> Frontend: 500 Internal Server Error\n{"message": "Failed to send email"}
      deactivate Controller
      Frontend --> Utilisateur: "Erreur lors de l'envoi\nde l'email. Réessayez."
    end

  end
end

deactivate Frontend

== Notes de sécurité ==

note over Utilisateur, SMTP
  **Mesures de sécurité implémentées** :

  1. **Validation multi-niveaux** :
     • Frontend (UX immédiate)
     • Backend (sécurité)
     • Base de données (contraintes)

  2. **Hashing irréversible** :
     • BCrypt avec salt unique
     • Impossible de retrouver le mot de passe original

  3. **OTP temporaire** :
     • Expire après 5 minutes
     • À usage unique (marqué comme utilisé après vérification)

  4. **Protection contre énumération** :
     • Message générique si email existe
     • Pas de détails sur l'utilisateur existant

  5. **Rate limiting recommandé** :
     • Max 5 inscriptions/heure par IP
     • Protection contre spam et abus
end note

note over Controller, DB
  **Améliorations possibles** :

  1. **CAPTCHA** : Protection contre bots (reCAPTCHA v3)
  2. **Email verification link** : Alternative/complément à l'OTP
  3. **Password strength indicator** : Feedback visuel frontend
  4. **Async email sending** : Ne pas bloquer la réponse HTTP
  5. **Resend OTP endpoint** : POST /auth/resend-otp
  6. **Blacklist emails jetables** : Bloquer temporary-mail.net, etc.
  7. **Vérification téléphone** : SMS OTP (international)
end note

@enduml
