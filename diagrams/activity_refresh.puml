@startuml Activity_Refresh_Token_CipeStudio

|Frontend|
start

note right
  **D√©clencheurs du refresh** :
  1. Automatique : Access token expir√© (401/403)
  2. Manuel : Avant l'expiration (proactif)
  3. Au chargement de l'application
end note

:D√©tecter besoin de\nnouveau access token;

note right
  **Cas d√©clencheurs** :
  ‚Ä¢ Requ√™te API ‚Üí 401 Unauthorized
  ‚Ä¢ Requ√™te API ‚Üí 403 Forbidden
  ‚Ä¢ Access token expir√© (JWT decode)
  ‚Ä¢ Refresh pr√©ventif avant expiration
end note

:Envoyer requ√™te\nPOST /refresh;

note right
  **Configuration requ√™te** :
  ‚Ä¢ URL : POST /refresh
  ‚Ä¢ Headers : Content-Type: application/json
  ‚Ä¢ Credentials : include (pour envoyer cookies)
  ‚Ä¢ Body : {} (vide, le refresh token est dans les cookies)

  **Cookies envoy√©s automatiquement** :
  ‚Ä¢ refresh_token (httpOnly)
  ‚Ä¢ access_token (httpOnly, expir√©)
end note

|Backend - RefreshTokenController|
:Recevoir requ√™te POST /refresh;

:Extraire refresh token\ndepuis les cookies;

if (Refresh token pr√©sent ?) then (non)
  #FFB6C1:Retourner 400\nBad Request;
  note right
    Message : "Refresh token manquant"
  end note
  |Frontend|
  :Supprimer tokens locaux;
  :Rediriger vers /login;
  stop
else (oui)
endif

|Backend - RefreshTokenService|
:Valider la signature JWT\ndu refresh token;

if (Signature valide ?) then (non)
  #FFB6C1:Lancer exception\nInvalidTokenException;
  |Backend - RefreshTokenController|
  :Retourner 401\nUnauthorized;
  note right
    Message : "Token invalide ou corrompu"
  end note
  |Frontend|
  :Supprimer tokens locaux;
  :Rediriger vers /login;
  stop
else (oui)
endif

:D√©coder le refresh token\n(extraire claims);

note right
  **Claims du refresh token** :
  ‚Ä¢ sub : userId
  ‚Ä¢ exp : expiration timestamp
  ‚Ä¢ iat : issued at timestamp
  ‚Ä¢ jti : token unique ID (optionnel)
end note

:V√©rifier la date\nd'expiration;

if (Token expir√© ?) then (oui)
  #FFB6C1:Lancer exception\nTokenExpiredException;
  |Backend - RefreshTokenController|
  :Retourner 401\nUnauthorized;
  note right
    Message : "Refresh token expir√©,
    veuillez vous reconnecter"
  end note
  |Frontend|
  :Supprimer tokens locaux;
  :Rediriger vers /login;
  stop
else (non)
endif

|Backend - RefreshTokenRepository|
:Rechercher le refresh token\nen base de donn√©es;

partition "V√©rification en base de donn√©es" {
  :SELECT * FROM refresh_tokens\nWHERE token = ? AND user_id = ?;

  if (Token trouv√© en DB ?) then (non)
    #FFB6C1:Token non trouv√©;
    note right
      **Cas possible** :
      ‚Ä¢ Token jamais cr√©√© (falsifi√©)
      ‚Ä¢ Token supprim√© manuellement
      ‚Ä¢ Nettoyage automatique effectu√©
    end note
    |Backend - RefreshTokenController|
    :Retourner 401\nUnauthorized;
    |Frontend|
    :Supprimer tokens locaux;
    :Rediriger vers /login;
    stop
  else (oui)
  endif

  if (Token r√©voqu√© ?) then (oui)
    #FFB6C1:Token blacklist√©;
    note right
      **R√©vocation possible par** :
      ‚Ä¢ Utilisateur : d√©connexion manuelle
      ‚Ä¢ Admin : blocage du compte
      ‚Ä¢ S√©curit√© : activit√© suspecte
    end note
    |Backend - RefreshTokenController|
    :Retourner 401\nUnauthorized;
    note right
      Message : "Session r√©voqu√©e,
      veuillez vous reconnecter"
    end note
    |Frontend|
    :Supprimer tokens locaux;
    :Rediriger vers /login;
    stop
  else (non)
  endif
}

|Backend - RefreshTokenService|
:Extraire userId\ndu refresh token;

|Backend - UserRepository|
:Rechercher l'utilisateur\npar ID;

if (Utilisateur existe ?) then (non)
  #FFB6C1:Utilisateur introuvable;
  |Backend - RefreshTokenController|
  :Retourner 401\nUnauthorized;
  |Frontend|
  :Supprimer tokens locaux;
  :Rediriger vers /login;
  stop
else (oui)
endif

if (Utilisateur bloqu√© ?) then (oui)
  #FFB6C1:Compte bloqu√©;
  note right
    is_blocked = TRUE
  end note
  |Backend - RefreshTokenController|
  :Retourner 403\nForbidden;
  note right
    Message : "Votre compte a √©t√© bloqu√©"
  end note
  |Frontend|
  :Supprimer tokens locaux;
  :Afficher message\n"Compte bloqu√©";
  stop
else (non)
endif

|Backend - JwtUtils|
partition "G√©n√©ration nouveau access token" {
  :Cr√©er nouveau JWT\navec claims utilisateur;

  note right
    **Claims du nouvel access token** :
    ‚Ä¢ sub : userId
    ‚Ä¢ email : user.email
    ‚Ä¢ role : user.role
    ‚Ä¢ exp : maintenant + 15 minutes
    ‚Ä¢ iat : maintenant
  end note

  :Signer le token avec\nla cl√© secr√®te;
}

|Backend - RefreshTokenController|
:Cr√©er cookie httpOnly\navec le nouvel access token;

note right
  **Configuration cookie** :
  ‚Ä¢ Name : "access_token"
  ‚Ä¢ Value : nouveau JWT
  ‚Ä¢ HttpOnly : true
  ‚Ä¢ Secure : true (HTTPS uniquement)
  ‚Ä¢ SameSite : Strict
  ‚Ä¢ MaxAge : 15 minutes
  ‚Ä¢ Path : /
end note

:Retourner 200 OK\navec nouveau cookie;

note right
  **Response** :
  {
    "message": "Token refreshed successfully"
  }

  + Cookie "access_token" dans headers
end note

|Frontend|
:Recevoir r√©ponse 200 OK;

:Nouveau access token\nautomatiquement stock√©\ndans les cookies;

note right
  Le navigateur stocke automatiquement
  le cookie httpOnly. Le frontend n'a pas
  besoin de manipuler le token.
end note

:Rejouer la requ√™te initiale\navec le nouveau token;

note right
  **Intercepteur Axios/Fetch** :
  Si la requ√™te initiale a √©chou√© avec 401,
  elle est automatiquement rejou√©e apr√®s
  le refresh r√©ussi.

  Exemple :
  1. GET /books ‚Üí 401 (token expir√©)
  2. POST /refresh ‚Üí 200 (nouveau token)
  3. GET /books ‚Üí 200 (avec nouveau token)
end note

if (Requ√™te rejou√©e\nr√©ussie ?) then (oui)
  :Afficher les donn√©es\n√† l'utilisateur;
  stop
else (non)
  #FFFFCC:Afficher erreur\nde la requ√™te;
  stop
endif

' Cas d'erreur r√©seau
|Frontend|
if (Erreur r√©seau\nlors du refresh ?) then (oui)
  #FFB6C1:Afficher message\n"Erreur de connexion";
  :R√©essayer apr√®s\nquelques secondes;
  stop
endif

legend right
  **M√©canisme de refresh automatique (Frontend)** :

  **1. Intercepteur de requ√™tes** :
  ```javascript
  // axios interceptor
  axios.interceptors.response.use(
    response => response,
    async error => {
      const originalRequest = error.config;

      // Si 401 et pas d√©j√† retry√©
      if (error.response?.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;

        try {
          // Tenter le refresh
          await axios.post('/refresh', {}, { withCredentials: true });

          // Rejouer la requ√™te originale
          return axios(originalRequest);
        } catch (refreshError) {
          // Refresh √©chou√© ‚Üí logout
          window.location.href = '/login';
          return Promise.reject(refreshError);
        }
      }

      return Promise.reject(error);
    }
  );
  ```

  **2. Refresh pr√©ventif** :
  ```javascript
  // Refresh 1 minute avant expiration
  useEffect(() => {
    const checkTokenExpiry = () => {
      const token = parseJwt(accessToken);
      const expiresIn = token.exp * 1000 - Date.now();

      if (expiresIn < 60000) { // < 1 minute
        fetch('/refresh', { credentials: 'include' });
      }
    };

    const interval = setInterval(checkTokenExpiry, 30000);
    return () => clearInterval(interval);
  }, []);
  ```

  **3. Gestion des erreurs** :
  ‚Ä¢ 401 lors du refresh ‚Üí Redirection /login
  ‚Ä¢ Token r√©voqu√© ‚Üí Message + redirection
  ‚Ä¢ Erreur r√©seau ‚Üí Retry avec backoff exponentiel
endlegend

note bottom
  **S√©curit√© et bonnes pratiques** :

  **1. Rotation des refresh tokens (recommand√©)** :
  ‚Ä¢ √Ä chaque refresh, g√©n√©rer aussi un nouveau refresh token
  ‚Ä¢ R√©voquer l'ancien refresh token
  ‚Ä¢ Emp√™che la r√©utilisation de tokens vol√©s

  **2. Token Binding (avanc√©)** :
  ‚Ä¢ Lier le refresh token √† l'IP ou fingerprint du client
  ‚Ä¢ D√©tecter les utilisations suspectes

  **3. D√©tection d'anomalies** :
  ‚Ä¢ Limiter le nombre de refresh par heure (rate limiting)
  ‚Ä¢ Logger tous les refresh (audit trail)
  ‚Ä¢ Alerte si refresh depuis plusieurs IPs diff√©rentes

  **4. Dur√©es de vie recommand√©es** :
  ‚Ä¢ Access token : 15 minutes (actuel)
  ‚Ä¢ Refresh token : 7-30 jours
  ‚Ä¢ √âquilibre s√©curit√© vs UX

  **5. Nettoyage automatique** :
  ‚Ä¢ Cron job pour supprimer les refresh tokens expir√©s
  ‚Ä¢ √âviter l'accumulation en base de donn√©es

  **6. R√©vocation globale** :
  ‚Ä¢ Endpoint /logout-all pour r√©voquer tous les tokens d'un user
  ‚Ä¢ Utile en cas de compte compromis

  **Impl√©mentation actuelle vs Recommandations** :
  ‚úÖ Actuellement impl√©ment√© :
  ‚Ä¢ Refresh token en base de donn√©es
  ‚Ä¢ V√©rification de r√©vocation
  ‚Ä¢ Cookies httpOnly s√©curis√©s

  üîÑ √Ä am√©liorer :
  ‚Ä¢ Rotation des refresh tokens
  ‚Ä¢ Rate limiting sur /refresh
  ‚Ä¢ Logging des refresh pour audit
  ‚Ä¢ Nettoyage automatique des tokens expir√©s
end note

@enduml
