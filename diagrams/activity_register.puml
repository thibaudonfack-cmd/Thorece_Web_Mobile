@startuml Activity_Register_CipeStudio

|Utilisateur|
start
:Accéder à la page\nd'inscription;
:Remplir le formulaire\n(nom, email, mot de passe, rôle);

note right
  **Informations requises** :
  • Nom complet
  • Email (unique)
  • Mot de passe (min 8 caractères)
  • Rôle (ENFANT, AUTEUR, EDITEUR)
end note

:Soumettre le formulaire;

|Frontend|
:Valider les données\ncôté client;

if (Données valides ?) then (non)
  :Afficher message\nd'erreur;
  |Utilisateur|
  :Corriger les erreurs;
  stop
else (oui)
  :Envoyer requête\nPOST /auth/register;
endif

|Backend - UserController|
:Recevoir RegisterRequestDTO;

:Valider avec\n@Valid annotations;

note right
  **Validations Backend** :
  • @NotBlank(name)
  • @Email(email)
  • @Size(min=8, password)
  • @NotNull(role)
end note

if (Validation OK ?) then (non)
  #FFB6C1:Retourner 400\nBad Request;
  |Frontend|
  :Afficher erreurs\nde validation;
  stop
else (oui)
endif

|Backend - UserService|
:Vérifier si email\nexiste déjà;

if (Email existe ?) then (oui)
  #FFB6C1:Lancer exception\nUserAlreadyExistsException;
  |Backend - UserController|
  :Retourner 409\nConflict;
  |Frontend|
  :Afficher message\n"Email déjà utilisé";
  stop
else (non)
endif

:Hasher le mot de passe\navec bcrypt;

note right
  **Sécurité** :
  • BCryptPasswordEncoder
  • Salt automatique (10 rounds)
  • Mot de passe original jamais stocké

  Exemple :
  "password123" → "$2a$10$N9qo8uL..."
end note

:Créer entité User\navec rôle sélectionné;

partition "Configuration utilisateur" {
  :Définir is_verified = FALSE;
  :Définir is_blocked = FALSE;
  :Générer code OTP\n(6 chiffres aléatoires);

  note right
    **OTP Generation** :
    • Random.nextInt(900000) + 100000
    • Résultat : 6 chiffres (ex: 482756)
    • Expiration : 5 minutes
  end note

  :Calculer otp_expiry_date\n(maintenant + 5 minutes);
}

|Backend - UserRepository|
:Sauvegarder l'utilisateur\nen base de données;

note right
  **Transaction SQL** :
  INSERT INTO users (
    name, email, password,
    role, is_verified, is_blocked,
    otp_code, otp_expiry_date,
    created_at, updated_at
  ) VALUES (...)
end note

|Backend - EmailService|
:Préparer email OTP;

partition "Envoi email OTP" {
  :Composer le message\navec code OTP;

  note right
    **Contenu email** :
    Subject: "Code de vérification Cipe Studio"
    Body:
    "Bonjour [nom],
    Votre code de vérification est : [OTP]
    Ce code expire dans 5 minutes."
  end note

  :Envoyer email via SMTP;

  if (Envoi réussi ?) then (non)
    #FFFFCC:Logger l'erreur\n(email non envoyé);
    note right
      **Cas d'erreur SMTP** :
      L'utilisateur est créé mais
      ne peut pas se connecter sans OTP.

      Fonctionnalité future :
      Bouton "Renvoyer OTP"
    end note
  else (oui)
    :Logger envoi réussi;
  endif
}

|Backend - UserController|
:Retourner 201 Created\navec RegisterResponseDTO;

note right
  **Response** :
  {
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "role": "AUTEUR",
    "isVerified": false
  }

  **Note** : Le mot de passe et l'OTP
  ne sont JAMAIS inclus dans la réponse
end note

|Frontend|
:Recevoir réponse 201;
:Sauvegarder email\nen sessionStorage;
:Rediriger vers\n/verify-otp;

|Utilisateur|
:Page de vérification OTP\naffichée;

note right
  **Page OTP** :
  • Champ de saisie OTP (6 chiffres)
  • Message : "Code envoyé à [email]"
  • Bouton "Vérifier"
  • Lien "Renvoyer le code" (optionnel)
end note

:Consulter email\net récupérer OTP;
:Saisir le code OTP;
:Soumettre pour\nvérification;

note right
  Le processus continue avec
  le diagramme sequence_verify_otp.puml
end note

stop

' Cas d'erreur réseau
|Frontend|
if (Erreur réseau ?) then (oui)
  #FFB6C1:Afficher message\n"Erreur de connexion";
  |Utilisateur|
  :Réessayer plus tard;
  stop
endif

legend right
  **Flux d'inscription complet** :

  1. **Validation Frontend** (instantanée)
     • Format email
     • Longueur mot de passe
     • Champs requis

  2. **Validation Backend** (Jakarta Validation)
     • @NotBlank, @Email, @Size
     • Contraintes métier

  3. **Vérification unicité** (email)
     • Query : SELECT COUNT(*) FROM users WHERE email = ?
     • Si existe → 409 Conflict

  4. **Hashing sécurisé** (bcrypt)
     • Irreversible
     • Salt unique par utilisateur

  5. **Génération OTP** (6 chiffres)
     • Aléatoire
     • Expiration 5 minutes

  6. **Envoi email** (SMTP)
     • Asynchrone (optionnel)
     • Retry en cas d'échec

  7. **Redirection OTP**
     • Email stocké temporairement
     • Utilisateur peut vérifier son compte

  **Sécurité** :
  • Mot de passe jamais en clair
  • OTP expire après 5 minutes
  • Email unique (contrainte DB)
  • Protection CSRF (cookies SameSite)
  • Rate limiting recommandé (éviter spam)
endlegend

note bottom
  **Améliorations possibles** :

  1. **Captcha** : Protection contre bots (reCAPTCHA)
  2. **Rate limiting** : Max 5 inscriptions/heure par IP
  3. **Email verification** : Lien de vérification en plus de l'OTP
  4. **Password strength meter** : Indicateur visuel frontend
  5. **Resend OTP** : Bouton pour renvoyer le code
  6. **Phone verification** : Alternative SMS (international)
  7. **OAuth2 Social Login** : Google, GitHub, etc.
end note

@enduml
