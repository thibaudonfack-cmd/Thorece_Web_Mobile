@startuml Architecture_Simple_vs_Scalable

!define LIGHTBLUE #E3F2FD
!define LIGHTGREEN #E8F5E9
!define LIGHTYELLOW #FFF9C4
!define LIGHTPINK #FCE4EC

' Architecture Simple (Actuelle)
package "Architecture Simple (Cipe Studio - Actuel)" as Simple {
  actor "Utilisateurs\n(< 1000)" as Users1

  cloud "Internet" as Net1

  node "Serveur Unique" {
    component [Nginx\n(Reverse Proxy)] as Nginx1
    component [Frontend React\n(Static Files)] as Front1
    component [Backend\nSpring Boot\n:8080] as Back1
    database [MySQL\n:3306] as DB1
    component [SeaweedFS\n:8333] as S3_1
  }

  Users1 --> Net1
  Net1 --> Nginx1
  Nginx1 --> Front1 : "/\n(port 80)"
  Nginx1 --> Back1 : "/api/*\n(proxy_pass)"
  Back1 --> DB1
  Back1 --> S3_1

  note right of Nginx1
    **Configuration Nginx** :
    • Port 80 (HTTP)
    • Serve frontend (/)
    • Proxy API (/api/*)
    • Gzip compression
    • Static caching
  end note
}

' Architecture Scalable (Future)
package "Architecture Scalable (Évolution future)" as Scalable {
  actor "Utilisateurs\n(> 10 000)" as Users2

  cloud "Internet" as Net2

  node "Load Balancer\n(HAProxy/Nginx)" as LB {
    component [Load Balancer\n+ SSL Termination] as LBComp
  }

  node "Frontend Cluster" {
    component [Frontend 1\n(CDN/Nginx)] as F1
    component [Frontend 2\n(CDN/Nginx)] as F2
  }

  node "Backend Cluster" {
    component [Backend 1\nSpring Boot] as B1
    component [Backend 2\nSpring Boot] as B2
    component [Backend 3\nSpring Boot] as B3
  }

  node "Database Cluster" {
    database [MySQL\nPrimary\n(Write)] as DBM
    database [MySQL\nReplica 1\n(Read)] as DBS1
    database [MySQL\nReplica 2\n(Read)] as DBS2
  }

  node "Cache Layer" {
    component [Redis\nCluster] as Redis
  }

  node "Storage Cluster" {
    cloud [SeaweedFS\nCluster\n(Distributed S3)] as S3C
  }

  node "Monitoring" {
    component [Prometheus +\nGrafana] as Monitor
  }

  Users2 --> Net2
  Net2 --> LBComp

  LBComp --> F1 : "Round Robin"
  LBComp --> F2

  F1 --> LBComp : "API calls"
  F2 --> LBComp

  LBComp --> B1 : "Least Connections"
  LBComp --> B2
  LBComp --> B3

  B1 --> DBM : "Writes"
  B2 --> DBM
  B3 --> DBM

  B1 --> DBS1 : "Reads"
  B1 --> DBS2
  B2 --> DBS1
  B2 --> DBS2
  B3 --> DBS1
  B3 --> DBS2

  DBM --> DBS1 : "Replication"
  DBM --> DBS2

  B1 --> Redis : "Session/Cache"
  B2 --> Redis
  B3 --> Redis

  B1 --> S3C
  B2 --> S3C
  B3 --> S3C

  Monitor --> B1
  Monitor --> B2
  Monitor --> B3
  Monitor --> DBM
  Monitor --> Redis

  note right of LB
    **Load Balancer** :
    • SSL/TLS Termination
    • Health checks
    • Sticky sessions (si nécessaire)
    • Rate limiting
    • DDoS protection
  end note

  note right of Redis
    **Cache distribué** :
    • Session partagée entre backends
    • Cache de requêtes fréquentes
    • Rate limiting distribué
    • Pub/Sub pour notifications
  end note

  note bottom of "Database Cluster"
    **MySQL Replication** :
    • Primary-Replica (Master-Slave)
    • Writes → Primary uniquement
    • Reads → Load balancing sur replicas
    • Failover automatique (ProxySQL/Orchestrator)
  end note
}

' Architecture Intermédiaire
package "Architecture Intermédiaire (1000-5000 utilisateurs)" as Medium {
  actor "Utilisateurs\n(1000-5000)" as Users3

  cloud "Internet" as Net3

  node "Web Server" {
    component [Nginx\n+ Frontend] as Nginx3
  }

  node "App Server 1" {
    component [Backend 1\nSpring Boot] as B3_1
  }

  node "App Server 2" {
    component [Backend 2\nSpring Boot] as B3_2
  }

  node "Database" {
    database [MySQL\nPrimary] as DB3M
    database [MySQL\nReplica] as DB3S
  }

  node "Storage" {
    component [SeaweedFS] as S3_3
  }

  Users3 --> Net3
  Net3 --> Nginx3
  Nginx3 --> B3_1 : "Load balancing"
  Nginx3 --> B3_2
  B3_1 --> DB3M : "Writes"
  B3_2 --> DB3M
  B3_1 --> DB3S : "Reads"
  B3_2 --> DB3S
  DB3M --> DB3S : "Replication"
  B3_1 --> S3_3
  B3_2 --> S3_3

  note right of Nginx3
    **Nginx Load Balancing** :
    • upstream backend {
        server app1:8080;
        server app2:8080;
      }
    • Algorithme : least_conn
  end note
}

note bottom of Simple
  **Quand utiliser ?**
  • Projet en démarrage
  • Budget limité
  • < 1000 utilisateurs simultanés
  • Équipe réduite
  • Simplicité prioritaire

  **Coût** : ~50-100€/mois (VPS)
end note

note bottom of Medium
  **Quand migrer ?**
  • 1000-5000 utilisateurs actifs
  • Pics de charge identifiés
  • Budget modéré
  • SLA > 99% requis

  **Coût** : ~200-500€/mois
end note

note bottom of Scalable
  **Quand migrer ?**
  • > 10 000 utilisateurs actifs
  • Haute disponibilité critique (99.9%)
  • Budget confortable
  • Équipe DevOps dédiée
  • Charge imprévisible

  **Coût** : ~1000-5000€/mois
end note

legend right
  **Stratégie de montée en charge** :

  **Phase 1** : Architecture simple
  ├─ Optimisations logicielles (caching, indexes)
  ├─ Monitoring et profiling
  └─ Identifier les bottlenecks

  **Phase 2** : Architecture intermédiaire
  ├─ Horizontal scaling du backend
  ├─ Read replicas pour la DB
  └─ Nginx load balancing

  **Phase 3** : Architecture scalable
  ├─ Load balancer dédié
  ├─ Cache distribué (Redis)
  ├─ CDN pour frontend/images
  ├─ Database clustering
  └─ Monitoring avancé (Prometheus/Grafana)

  **Principe** : Scale progressivement selon les besoins réels
endlegend

@enduml
